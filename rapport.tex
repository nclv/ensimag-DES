\documentclass[a4paper, 10pt, french]{article}
% Préambule; packages qui peuvent être utiles
   \RequirePackage[T1]{fontenc}        % Ce package pourrit les pdf...
   \RequirePackage{babel,indentfirst}  % Pour les césures correctes,
                                       % et pour indenter au début de chaque paragraphe
   \RequirePackage[utf8]{inputenc}   % Pour pouvoir utiliser directement les accents
                                     % et autres caractères français
   % \RequirePackage{lmodern,tgpagella} % Police de caractères
   \textwidth 17cm \textheight 25cm \oddsidemargin -0.24cm % Définition taille de la page
   \evensidemargin -1.24cm \topskip 0cm \headheight -1.5cm % Définition des marges
   \RequirePackage{latexsym}                  % Symboles
   \RequirePackage{amsmath}                   % Symboles mathématiques
   \RequirePackage{tikz}   % Pour faire des schémas
   \RequirePackage{graphicx} % Pour inclure des images
   \RequirePackage{listings} % pour mettre des listings
% Fin Préambule; package qui peuvent être utiles

\title{Rapport de Simulation d'une équipe de robots pompiers}
\author{Groupe X}
\begin{document}

\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Données du problème}	

	\subsection{Carte}
	Une carte est représentée par une table de hachage non-modifiable dont les clés, représentées par des entiers et correspondant aux cases, sont associées à la nature du terrain correspondant (type énuméré). 
	Plus précisèment, une case $(i, j)$ est identifié par l'entier $i * largeur + j$ où $largeur$ représente la largeur de la carte. La classe définissant une carte est disponible dans le fichier {\it Carte.java} du package {\it Game}.
	\par\leavevmode\par
	Notons que les complexités des opérations d'une table de hachage sont identiques à celles d'une matrice 2D dans le cadre de notre problème. Par ailleurs, précisons qu'on s'affranchit de tous espaces mémoires inutiles dans le cas où dans un futur proche, nous souhaiterions gérer le cas de cartes non-rectangulaires : le problème serait plus simple à gérer, à raison de modifier le système de coordonnées.

	\subsection{Incendies}
	Les incendies sont caractéristiques des données d'une simulation. Ceux-ci sont représentés par une table de hachage, attribut de la classe {\it DonneesSimulation}, dont les clés sont des entiers (position de l'incendie) associées à des entiers (intensité de l'incendie). Une des forces de ce stockage est de pouvoir itérer simplement sur tous les incendies, sans avoir besoin de parcourir toute la carte. Ainsi, on a une connaissance à tout instant des incendies courants.

	\subsection{Robots}
	Pour représenter les robots, nous proposons une représentation basé sur un {\it pattern design type-object}. Cette représentation propose des avantages multiples, notamment elle permet de modifier ou d'ajouter de nouveaux types sans avoir à recompiler ou à changer du code (contrairement à l'héritage qui nécessite de créer de nouvelles classes). Néanmoins, ce design-pattern n'inclut pas l'ajout de nouvelles fonctionnalités propres à un robot, mais dans le cadre de notre problème, ce choix est intéressant.
	\par\leavevmode\par
	Un robot est caractérisé par son type, objet instancié dans une classe non-modifiable {\it MyRobotTypes} contenant la déclaration de tous les types de robots nécessaires à la simulation. La classe {\it RobotTypes} contient le constructeur et méthodes nécessaires pour l'instanciation des robots dans {\it MyRobotTypes}. Pour plus de simplicité sur la gestion des événements, un robot est identifié par un nombre entier et par une position initiale sur une case de la carte. Toutes les classes définies pour les robots se situent dans le package {\it Game.Robots}.

	\subsection{Interface Graphique}
	Nous disposons d'une classe {\it TileImg} implémentant {\it GraphicalElement} pour représenter les images. Une image est caractérisée par un fond, sur lequel on superpose plusieurs motifs qui peuvent être les robots et/ou les incendies. L'interface graphique en lui-même est défini par une classe {\it GraphicsComponent} contenant un buffer des images pour ne pas avoir besoin de les recharger à chaque affichage, les données de simulation du problème et des méthodes définies pour normaliser, placer les robots et incendies. Toutes les classes définies pour l'interface graphique se situent dans le package {\it Game.Graphics}.

\section{Simulation de scénarios}

	\subsection{Données des simulations}
	Une simulation est caractérisée par une carte, une table de hachage pour les incendies (comme expliqué en 1.2) et une table de hachage pour les robots dont les clés sont des entiers (positions) associées à une liste chainée des identifiants des robots (plusieurs robots peuvent se trouver sur une même position). Notamment, une simulation représentée par une classe {\it DonneesSimulation} possède deux méthodes déterminant le temps nécessaire pour se déplacer d'une case à une autre et le temps nécessaire pour un robot de déverser l'eau sur l'incendie.
	
	\subsection{Simulateur}
	Un simulateur est une entité exécutant une simulation donnée. Notamment, un simulateur, à partir de données de simulation, ordonnance les événements des entités sur la carte. Ce simulateur est ajustable dans le choix où une stratégie est donnée. La méthode {\it next()} exécute le prochain événement, soumis ou non à une stratégie donnée. Quant à la méthode {\it restart()}, le simulateur sauvegarde toujours une copie des données de simulation. 
	\par\leavevmode\par
	Une action est une entité agissant sur les données d'une simulation. Représentée par une classe abstraite, une action doit nécessairement, pouvoir être exécutée et avoir une durée.
	Un robot peut effectuer plusieurs actions, chacune représentées par des classes filles :
	\begin{enumerate}
		\item ActionEmpty : déverser de l'eau sur un incendie.
		\item ActionFill : se remplir si le robot est sur de l'eau ou à côté.
		\item ActionMove : se déplacer vers une case voisine si c'est possible.
	\end{enumerate}
	\par\leavevmode\par
	Un événement est décrit par une date et une action. Tous les événements sont gérés par une entité {\it EventManager} les ordonnan{\c c}ant selon leur date respective. Plus précisèment, nous disposons d'une file de prioriété basée sur un comparateur des dates des événements.  

\section{Calculs de plus courts chemins}


\section{Résolution du problème}

\section{Expérimentations}

	\subsection{Tests}

	\subsection{Résultats}

\section{Conclusion}

\end{document}

%% Fin mise au format

